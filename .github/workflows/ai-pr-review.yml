name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  ai-review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: AI Code Review
        uses: actions/github-script@v7
        with:
          script: |
            const OPENROUTER_API_KEY = '${{ secrets.OPENROUTER_API_KEY }}';

            const diff = await github.rest.repos.compareCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base: context.payload.pull_request.base.sha,
              head: context.payload.pull_request.head.sha
            });

            // 모든 변경 파일 리뷰 (바이너리 제외)
            const filesToReview = diff.data.files.filter(file =>
              file.patch && // 패치가 있는 파일만 (바이너리 제외)
              !file.filename.includes('test/resources/') &&
              !file.filename.includes('build/')
            );

            if (filesToReview.length === 0) {
              console.log('No files to review');
              return;
            }

            console.log(`Found ${filesToReview.length} files to review`);

            // 파일 타입별 분류
            const fileCategories = {
              entities: [],
              services: [],
              controllers: [],
              dtos: [],
              repositories: [],
              configs: [],
              tests: [],
              others: []
            };

            filesToReview.forEach(file => {
              if (file.filename.includes('/entity/')) fileCategories.entities.push(file);
              else if (file.filename.includes('/service/')) fileCategories.services.push(file);
              else if (file.filename.includes('/controller/')) fileCategories.controllers.push(file);
              else if (file.filename.includes('/dto/')) fileCategories.dtos.push(file);
              else if (file.filename.includes('/repository/')) fileCategories.repositories.push(file);
              else if (file.filename.includes('/config/') || file.filename.endsWith('.yml') || file.filename.endsWith('.yaml')) fileCategories.configs.push(file);
              else if (file.filename.includes('/test/')) fileCategories.tests.push(file);
              else fileCategories.others.push(file);
            });

            // 전체 변경사항 요약
            const summary = {
              total: filesToReview.length,
              additions: diff.data.files.reduce((sum, f) => sum + f.additions, 0),
              deletions: diff.data.files.reduce((sum, f) => sum + f.deletions, 0),
              categories: Object.entries(fileCategories).filter(([_, files]) => files.length > 0)
                .map(([category, files]) => `${category}: ${files.length}개`)
            };

            // PR 전체 리뷰 시작
            let overallReview = `# 🤖 AI 코드 리뷰 보고서\n\n`;
            overallReview += `## 📊 변경 통계\n`;
            overallReview += `- **총 파일 수**: ${summary.total}개\n`;
            overallReview += `- **추가된 라인**: +${summary.additions}\n`;
            overallReview += `- **삭제된 라인**: -${summary.deletions}\n`;
            overallReview += `- **카테고리별**: ${summary.categories.join(', ')}\n\n`;

            // 아키텍처 레벨 리뷰를 위한 전체 컨텍스트 수집
            const architectureContext = {
              hasEntityChanges: fileCategories.entities.length > 0,
              hasServiceChanges: fileCategories.services.length > 0,
              hasControllerChanges: fileCategories.controllers.length > 0,
              hasDtoChanges: fileCategories.dtos.length > 0,
              hasTestChanges: fileCategories.tests.length > 0,
              fileNames: filesToReview.map(f => f.filename)
            };

            // 모든 파일 변경사항을 하나의 요청으로 통합
            overallReview += `## 📝 코드 리뷰\n\n`;

            // 전체 변경사항을 한번에 수집
            let allChanges = '';
            const filesSummary = [];

            for (const file of filesToReview) {
              filesSummary.push(`- ${file.filename} (+${file.additions}/-${file.deletions})`);
              allChanges += `\n### ${file.filename}\n`;
              allChanges += `\`\`\`diff\n${file.patch}\n\`\`\`\n`;
            }

            console.log('Sending single API request for all files...');

            try {
              const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: 'deepseek/deepseek-chat-v3.1:free',  //
                  messages: [{
                    role: 'system',
                    content: `당신은 AI Counseling App 프로젝트의 코드 리뷰어입니다.
                    이 프로젝트는 Spring Boot + Kotlin으로 구현된 AI 철학자 상담 서비스입니다.

                    ## 🔴 필수 이해 사항 - 응답 처리 체인

                    1. **RsData 응답 래퍼 (절대 규칙)**
                       - 모든 Controller는 반드시 RsData<T> 반환
                       - 성공: RsData.of("S-1", "메시지", data)
                       - 실패: RsData.of("F-XXX", "에러메시지", null)
                       - ❌ 절대 금지: ResponseEntity 직접 생성, 원시 타입 반환

                    2. **ResponseAspect AOP 자동 처리**
                       - @RestController의 모든 메서드를 인터셉트
                       - RsData의 resultCode를 HTTP 상태로 자동 매핑
                       - "S-1"/"200" → 200 OK, "201" → 201 CREATED
                       - "F-1"/"400" → 400 BAD_REQUEST, "401" → 401 UNAUTHORIZED

                    3. **Rq 요청 컨텍스트 (인증 패턴)**
                       - @RequestScope 컴포넌트로 주입받아 사용
                       - 올바른 패턴: val userId = rq.currentUserId ?: return RsData.of("F-401", "로그인이 필요합니다", null)
                       - ❌ 잘못된 패턴: SecurityContextHolder 직접 사용

                    ## 🔴 예외 처리 체인

                    - GlobalExceptionHandler가 모든 예외를 RsData로 변환
                    - BusinessException 계층 사용 (UnauthorizedException, NotFoundException 등)
                    - 모든 메시지는 한국어로 작성

                    ## 🔴 도메인 구조 패턴

                    1. **DDD 기반 패키지 구조**
                       domain/{aggregate}/
                       ├── controller/ - RsData 반환, Rq 주입
                       ├── service/    - 비즈니스 로직, DTO 반환 (Entity 반환 금지)
                       ├── repository/ - JpaRepository 상속
                       ├── entity/     - BaseEntity 상속 필수
                       └── dto/        - data class, @field: 검증 어노테이션

                    2. **BaseEntity 상속**: 모든 Entity는 BaseEntity 상속 (id, createdAt, updatedAt 자동)
                    3. **AppConstants 사용**: 모든 상수는 AppConstants에 정의

                    ## 리뷰 체크리스트

                    #### 📄 [파일명]
                    ✅ **패턴 준수**: RsData 반환, Rq 사용, BaseEntity 상속 체크
                    🟢 **Good**: 프로젝트 패턴을 잘 따른 부분
                    🟡 **Suggest**: 개선 제안
                    🔴 **Issue**: 패턴 위반 (반드시 수정)

                    특히 확인:
                    □ Controller가 RsData 반환하는가?
                    □ Rq.currentUserId로 인증 확인하는가?
                    □ Service가 DTO 반환하는가? (Entity 직접 반환 금지)
                    □ Entity가 BaseEntity 상속하는가?
                    □ 상수는 AppConstants 사용하는가?
                    □ 한국어 메시지 사용하는가?

                    코드 예시는 반드시 이 프로젝트 패턴을 따라 작성하세요.`
                  }, {
                    role: 'user',
                    content: `다음 PR의 ${filesToReview.length}개 파일을 리뷰해주세요:

                    변경된 파일:
                    ${filesSummary.join('\n')}

                    전체 변경사항:
                    ${allChanges}

                    각 파일별로 구체적인 리뷰를 제공해주세요.`
                  }],
                  max_tokens: 40000,  // 전체 리뷰를 위해 토큰 증가
                  temperature: 0.3
                })
              });

              if (response.ok) {
                const result = await response.json();
                overallReview += result.choices[0].message.content + '\n\n';
                console.log('✅ Single API review completed successfully!');
              } else {
                const errorText = await response.text();
                console.error('API request failed:', response.status, errorText);
                overallReview += `> ⚠️ 리뷰 실패: ${response.status} - ${errorText}\n\n`;
              }
            } catch (error) {
              console.error('Error during review:', error);
              overallReview += `> ⚠️ 리뷰 실패: ${error.message}\n\n`;
            }

            // 체크리스트 추가
            overallReview += `## ✅ 체크리스트\n\n`;
            overallReview += `- [ ] 모든 테스트가 통과하는가?\n`;
            overallReview += `- [ ] Ktlint 규칙을 준수하는가?\n`;
            overallReview += `- [ ] API 문서가 업데이트되었는가?\n`;
            overallReview += `- [ ] 마이그레이션 스크립트가 필요한가?\n`;
            overallReview += `- [ ] 보안 취약점은 없는가?\n\n`;

            overallReview += `---\n`;
            overallReview += `*🤖 AI Review powered by Deepseek 3.1 via OpenRouter*\n`;
            overallReview += `*⏱️ Reviewed at: ${new Date().toISOString()}*`;

            // 최종 리뷰 제출
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
              body: overallReview,
              event: 'COMMENT'
            });

            console.log(`✅ Review completed for ${filesToReview.length} files!`);
